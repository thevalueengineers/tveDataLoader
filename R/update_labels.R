#' Update variable labels of a `labelled` tibble
#'
#' Updates the variable labels of a tibble using
#' [labelled::set_variable_labels()]. The variables to be update should all have
#' a row in `new_var_labels`. Variables that don't won't be changed and will
#' keep their existing label.
#'
#' @param dat Tibble containing variables to be updated
#' @param new_var_labels Tibble with two columns, variable and label. i.e. the
#'   format generated by [tveDataLoader::get_varLabels()]. Column names don't
#'   matter, but the first column will be used as variable and the second as
#'   label, so they must be in that order.
#'
#' @examples
#' dat <- tibble(a = 1, b = 2)
#' tveDataLoader::get_varLabels(dat)
#' new_var_labs <- tibble::tribble(
#'   ~variable, ~label,
#'   "a", "variable 1",
#'   "b", "variable 2"
#' )
#' dat <- update_var_labels(dat, new_var_labs)
#' tveDataLoader::get_varLabels(dat)
#'
#' @returns Version of dat with the updated variable labels applied
#' @export
update_var_labels <- function(dat, new_var_labels) {
  assertthat::assert_that(
    is.data.frame(dat),
    msg = "data to relable must be a data frame"
  )
  assertthat::assert_that(
    and(is.data.frame(new_var_labels), ncol(new_var_labels) == 2),
    msg = "new_var_labels should be a data frame with 2 columns"
  )
  assertthat::assert_that(
    all(as.character(sapply(new_var_labels, class)) == rep("character", 2)),
    msg = "Columns of new_var_labels should be character"
  )

  new_var_labels_ls <- split(new_var_labels, new_var_labels[1]) |>
    lapply(tibble::deframe) |>
    lapply(unname)

  dat |>
    labelled::set_variable_labels(.labels = new_var_labels_ls)
}

#' Update value labels of a `labelled` tibble
#'
#' Updates the value labels of a tibble using
#' [labelled::set_value_labels()]. The values of the variables to be update should all have
#' a row in `new_val_labels`. Variables that don't won't be changed and will
#' keep their existing label.
#'
#' @param dat Tibble containing variables to be updated
#' @param new_val_labels Tibble with three columns, variable, value and value
#'   label. i.e. the format generated by [tveDataLoader::get_valLabels()].
#'   Column names don't matter, but the first column will be used as variable,
#'   the second as value and the third as value label, so they must be in that
#'   order.
#'
#' @examples
#' dat <- tibble(
#'   a = labelled::labelled(c(1, 2), labels = c("value 1" = 1, "value 2" = 2))
#' )
#' tveDataLoader::get_valLabels(dat)
#' new_val_labs <- tibble::tribble(
#'   ~variable, ~value, ~`value label`,
#'   "a", 1, "new value 1",
#'   "a", 2, "new value 2"
#' )
#' dat <- update_val_labels(dat, new_val_labs)
#' tveDataLoader::get_valLabels(dat)
#'
#' @returns Version of dat with the updated variable labels applied
#' @export
update_val_labels <- function(dat, new_val_labels) {

  assertthat::assert_that(
    is.data.frame(dat),
    msg = "data to relable must be a data frame"
  )
  assertthat::assert_that(
    and(is.data.frame(new_val_labels), ncol(new_val_labels) == 3),
    msg = "new_val_labels should be a data frame with 3 columns"
  )
  # no checking of new_val_labels col types because we can't assume the value
  # column will be numeric

  new_val_labels_ls <- split(new_val_labels, new_val_labels[1]) |> # assume variable is col 1
    lapply(function(x) x[c(3, 2)]) |> # assume value is col 2 and value label is col 3
    lapply(tibble::deframe)

  dat |>
    labelled::set_value_labels(.labels = new_val_labels_ls)
}
